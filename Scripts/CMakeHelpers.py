# ----------------------------------------------------------------------
# |
# |  CMakeHelpers.py
# |
# |  David Brownell <db@DavidBrownell.com>
# |      2022-09-24 14:00:11
# |
# ----------------------------------------------------------------------
# |
# |  Copyright David Brownell 2022
# |  Distributed under the Boost Software License, Version 1.0. See
# |  accompanying file LICENSE_1_0.txt or copy at
# |  http://www.boost.org/LICENSE_1_0.txt.
# |
# ----------------------------------------------------------------------
"""Functionality that simplifies common activities with CMake."""

import datetime
import os
import textwrap
import threading

from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Callable, List, Optional, TextIO, Tuple

import typer

from typer.core import TyperGroup

from Common_Foundation import PathEx
from Common_Foundation.Shell.All import CurrentShell
from Common_Foundation.Streams.DoneManager import DoneManager, DoneManagerFlags
from Common_Foundation.Streams.StreamDecorator import StreamDecorator
from Common_Foundation import SubprocessEx
from Common_Foundation import TextwrapEx
from Common_Foundation import Types

from Common_FoundationEx import ExecuteTasks
from Common_FoundationEx.InflectEx import inflect


# ----------------------------------------------------------------------
class NaturalOrderGrouper(TyperGroup):
    # ----------------------------------------------------------------------
    def list_commands(self, *args, **kwargs):  # pylint: disable=unused-argument
        return self.commands.keys()


# ----------------------------------------------------------------------
app                                         = typer.Typer(
    cls=NaturalOrderGrouper,
    no_args_is_help=True,
    pretty_exceptions_show_locals=False,
)


# ----------------------------------------------------------------------
class Configuration(Enum):
    Debug                                   = "Debug"
    Release                                 = "Release"
    ReleaseMinSize                          = "ReleaseMinSize"
    ReleaseNoOpt                            = "ReleaseNoOpt"


# ----------------------------------------------------------------------
def _ValidateWorkingDir(
    value: Path,
) -> Path:
    if not (value / "CMakeLists.txt").is_file():
        raise typer.BadParameter("'{}' does not contain 'CMakeLists.txt'.".format(value))

    return value


# ----------------------------------------------------------------------
_configurations_option_info                 = typer.Option(["Debug", "Release"], "--configuration", help="CMake configurations to build.")
_working_dir_option_info                    = typer.Option(Path.cwd(), "--working-dir", callback=_ValidateWorkingDir, help="Directory containing 'CMakeLists.txt'.")

_verbose_option_info                        = typer.Option(False, "--verbose", help="Write verbose information to the terminal.")
_debug_option_info                          = typer.Option(False, "--debug", help="Write additional debug information to the terminal.")
_quiet_option_info                          = typer.Option(False, "--quiet", help="Write less output to the terminal.")
_max_num_threads_option_info                = typer.Option(None, "--max-num-threads", min=1, help="Limit the number of threads used to complete the activity.")


# ----------------------------------------------------------------------
@app.command("Generate")
def Generate(
    configuration_values: List[Configuration]=_configurations_option_info,
    working_dir: Path=_working_dir_option_info,
    generator: str=typer.Option("Ninja", "--generator", help="CMake generator to use when building."),
    cmake_params: Optional[List[str]]=typer.Option(None, "--cmake-param", help="Parameter to pass to CMake."),
    force: bool=typer.Option(False, "--force", help="Overwrite any previously content generated by CMake."),
    build: bool=typer.Option(False, "--build", help="Build after CMake generation is complete."),
    test: bool=typer.Option(False, "--test", help="Test after CMake building is complete."),
    verbose: bool=_verbose_option_info,
    debug: bool=_debug_option_info,
    quiet: bool=_quiet_option_info,
    max_num_threads: Optional[int]=_max_num_threads_option_info,
) -> None:
    """Generates CMake build directories that can be used along side CMake build directories for different compilers, operating systems, architectures, and configurations."""

    configurations: List[str] = [config.value for config in configuration_values]

    if test:
        build = True

    command_line_template = 'cmake{generator} -S "{working_dir}" -B "{{build_dir}}" -DCMAKE_BUILD_TYPE={{configuration}}{params}'.format(
        generator="" if not generator else ' -G "{}"'.format(generator),
        working_dir=working_dir,
        params="" if not cmake_params else " {}".format(" ".join(cmake_params)),
    )

    # ----------------------------------------------------------------------
    def Execute(
        build_dir: Path,
        log_filename: Path,
        configuration: str,
        on_status_func: Callable[[int, str], bool],
    ) -> Tuple[int, Optional[str]]:
        command_line = command_line_template.format(
            build_dir=build_dir,
            configuration=configuration,
        )

        if build_dir.is_dir():
            if not force:
                with log_filename.open("a+") as f:
                    f.write("\nThe output dir '{}' already exists and will not be overwritten. Specify '--force' on the command line to ignore this message and overwrite the existing content.\n".format(build_dir))
                    return 1, "Dir already exists"

            PathEx.RemoveTree(build_dir)

        build_dir.mkdir(parents=True, exist_ok=True)

        with log_filename.open("w") as f:
            on_status_func(1, "Generating")
            _PrintHeader("Generate Output", f)

            f.write("Command line: {}\n\n".format(command_line))

            result = SubprocessEx.Run(command_line)

            f.write(result.output)

            if result.returncode != 0:
                return result.returncode, None

            # Create a python file that can be used to clean the directory
            existing_items = list(build_dir.iterdir())
            assert existing_items

            with (build_dir / "Clean.py").open("w") as clean_file:
                clean_file.write(
                    textwrap.dedent(
                        """\
                        #!/usr/bin/env python

                        import os

                        from pathlib import Path
                        from typing import List, Set

                        import typer

                        from Common_Foundation import PathEx
                        from Common_Foundation.Streams.DoneManager import DoneManager, DoneManagerFlags


                        # ----------------------------------------------------------------------
                        app = typer.Typer(
                            pretty_exceptions_show_locals=False,
                        )


                        # ----------------------------------------------------------------------
                        @app.command()
                        def EntryPoint(
                            all: bool=typer.Option(False, "--all", help="Clean all content (including test output)."),
                            verbose: bool=typer.Option(False, "--verbose", help="Write verbose information to the terminal."),
                            debug: bool=typer.Option(False, "--debug", help="Write additional debug information to the terminal."),
                        ) -> None:
                            with DoneManager.CreateCommandLine(
                                output_flags=DoneManagerFlags.Create(verbose=verbose, debug=debug),
                            ) as dm:
                                existing_items: Set[Path] = set(
                                    [
                                        {existing_items_list}
                                    ]
                                )

                                this_dir = Path(__file__).parent
                                assert this_dir.is_dir(), this_dir

                                for item in this_dir.iterdir():
                                    if item in existing_items or item.name == "Clean.py":
                                        continue

                                    with dm.Nested("Removing '{{}}'...".format(item)):
                                        if item.is_dir():
                                            PathEx.RemoveTree(item)
                                        elif item.is_file():
                                            PathEx.RemoveFile(item)
                                        else:
                                            assert False, item  # pragma: no cover

                                cmake_dirs = this_dir / "CMakeFiles"

                                if all:
                                    with dm.Nested("Removing '{{}}'...".format(cmake_dirs)):
                                        PathEx.RemoveTree(cmake_dirs)
                                else:
                                    dirs_to_delete: List[Path] = []

                                    for root, directories, filenames in os.walk(cmake_dirs):
                                        root = Path(root)

                                        if root.suffix == ".dir":
                                            dirs_to_delete.append(root)

                                    for dir_to_delete in dirs_to_delete:
                                        with dm.Nested("Removing '{{}}'...".format(dir_to_delete)):
                                            PathEx.RemoveTree(dir_to_delete)


                        # ----------------------------------------------------------------------
                        # ----------------------------------------------------------------------
                        # ----------------------------------------------------------------------
                        if __name__ == "__main__":
                            app()
                        """,
                    ).format(
                        existing_items_list=TextwrapEx.Indent(
                            "\n".join('Path(r"{}"),'.format(existing_item) for existing_item in existing_items),
                            16,
                            skip_first_line=True,
                        ),
                    ),
                )

            if build:
                on_status_func(2, "Building")
                _PrintHeader("Build Output", f)

                result = _BuildImpl(build_dir, f)
                if result != 0:
                    return result, "Build Failure"

            if test:
                on_status_func(3, "Testing")
                _PrintHeader("Test Output", f)

                result = _TestImpl(build_dir, f)
                if result != 0:
                    return result, "Test Failure"

            return 0, None

    # ----------------------------------------------------------------------

    _Impl(
        configurations,
        working_dir,
        "Generating",
        "Generate.log",
        1 + (1 if build else 0) + (1 if test else 0),
        Execute,
        verbose=verbose,
        debug=debug,
        quiet=quiet,
        max_num_threads=max_num_threads,
    )


# ----------------------------------------------------------------------
@app.command("Build")
def Build(
    configuration_values: List[Configuration]=_configurations_option_info,
    working_dir: Path=_working_dir_option_info,
    test: bool=typer.Option(False, "--test", help="Test after CMake building is complete."),
    verbose: bool=_verbose_option_info,
    debug: bool=_debug_option_info,
    quiet: bool=_quiet_option_info,
    max_num_threads: Optional[int]=_max_num_threads_option_info,
) -> None:
    """Builds all of the provided configurations."""

    configurations: List[str] = [config.value for config in configuration_values]

    # ----------------------------------------------------------------------
    def Execute(
        build_dir: Path,
        log_filename: Path,
        configuration: str,
        on_status_func: Callable[[int, str], bool],
    ) -> Tuple[int, Optional[str]]:
        with log_filename.open("w") as f:
            on_status_func(1, "Building")
            _PrintHeader("Build Output", f)

            result = _BuildImpl(build_dir, f)
            if result != 0:
                return result, "Build Failure"

            if test:
                on_status_func(2, "Testing")
                _PrintHeader("Test Output", f)

                result = _TestImpl(build_dir, f)
                if result != 0:
                    return result, "Test Failure"

            return 0, None

    # ----------------------------------------------------------------------

    _Impl(
        configurations,
        working_dir,
        "Building",
        "Build.log",
        1 + (1 if test else 0),
        Execute,
        verbose=verbose,
        debug=debug,
        quiet=quiet,
        max_num_threads=max_num_threads,
    )


# ----------------------------------------------------------------------
@app.command("Test")
def Test(
    configuration_values: List[Configuration]=_configurations_option_info,
    working_dir: Path=_working_dir_option_info,
    verbose: bool=_verbose_option_info,
    debug: bool=_debug_option_info,
    quiet: bool=_quiet_option_info,
    max_num_threads: Optional[int]=_max_num_threads_option_info,
) -> None:
    """Tests all of the provided configurations."""

    configurations: List[str] = [config.value for config in configuration_values]

    # ----------------------------------------------------------------------
    def Execute(
        build_dir: Path,
        log_filename: Path,
        configuration: str,
        on_status_func: Callable[[int, str], bool],
    ) -> Tuple[int, Optional[str]]:
        with log_filename.open("w") as f:
            on_status_func(1, "Testing")
            _PrintHeader("Test Output", f)

            result = _TestImpl(build_dir, f)
            if result != 0:
                return result, "Test Failure"

        return 0, None

    # ----------------------------------------------------------------------

    _Impl(
        configurations,
        working_dir,
        "Testing",
        "Test.log",
        1,
        Execute,
        verbose=verbose,
        debug=debug,
        quiet=quiet,
        max_num_threads=max_num_threads,
    )


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
def _Impl(
    configurations: List[str],
    working_dir: Path,
    desc: str,
    log_name: str,
    num_steps: int,
    execute_func: Callable[
        [
            Path,                                       # build_dir
            Path,                                       # log_filename
            str,                                        # configuration
            Callable[[Optional[int], str], bool],       # on_status_func
        ],
        Tuple[int, Optional[str]],
    ],
    *,
    verbose: bool,
    debug: bool,
    quiet: bool,
    max_num_threads: Optional[int],
) -> None:
    with DoneManager.CreateCommandLine(
        output_flags=DoneManagerFlags.Create(verbose=verbose, debug=debug),
    ) as dm:
        # ----------------------------------------------------------------------
        @dataclass
        class TaskDataContext(object):
            configuration: str
            build_dir: Path

            log_filename: Path

            result: int                                 = field(init=False)
            short_desc: Optional[str]                   = field(init=False)
            execution_time: datetime.timedelta          = field(init=False)

        # ----------------------------------------------------------------------
        def Step1Callback(
            context: TaskDataContext,
        ):
            # ----------------------------------------------------------------------
            def Step2Callback(
                on_simple_status_func: Callable[[str], None],  # pylint: disable=unused-argument
            ):
                return num_steps, Step3Callback

            # ----------------------------------------------------------------------
            def Step3Callback(
                status: ExecuteTasks.Status,
            ):
                return execute_func(
                    context.build_dir,
                    context.log_filename,
                    context.configuration,
                    status.OnProgress,
                )

            # ----------------------------------------------------------------------

            return context.log_filename, Step2Callback

        # ----------------------------------------------------------------------

        build_dir_root: Path = (
            working_dir
            / "build"
            / CurrentShell.family_name
            / Types.EnsureValid(os.getenv("DEVELOPMENT_ENVIRONMENT_CPP_COMPILER_NAME"))
            / Types.EnsureValid(os.getenv("DEVELOPMENT_ENVIRONMENT_CPP_ARCHITECTURE"))
        )

        task_data_items = [
            ExecuteTasks.TaskData(
                configuration,
                TaskDataContext(
                    configuration,
                    build_dir_root / configuration,
                    build_dir_root / configuration / log_name,
                ),
                threading.Lock(),
            )
            for configuration in configurations
        ]

        ExecuteTasks.ExecuteTasks(
            dm,
            desc,
            task_data_items,
            Step1Callback,
            quiet=quiet,
            max_num_threads=max_num_threads,
        )

        with dm.YieldStream() as stream:
            rows: List[List[str]] = []

            for task_data_item in task_data_items:
                rows.append(
                    [
                        task_data_item.context.configuration,
                        "Failed ({})".format(task_data_item.result) if task_data_item.result < 0
                            else "Unknown ({})".format(task_data_item.result) if task_data_item.result > 0
                            else "Succeeded ({})".format(task_data_item.result)
                        ,
                        str(task_data_item.execution_time),
                        str(task_data_item.context.build_dir) if dm.capabilities.is_headless else "{} [View]".format(
                            inflect.no("item", sum(1 for _ in task_data_item.context.build_dir.iterdir())),
                        ),
                        str(task_data_item.log_filename) if dm.capabilities.is_headless else "{} [View Log]".format(
                            TextwrapEx.GetSizeDisplay(task_data_item.log_filename.stat().st_size) if task_data_item.log_filename.is_file() else "",
                        ),
                        task_data_item.short_desc or "",
                    ],
                )

            if dm.capabilities.supports_colors:
                success_on = TextwrapEx.SUCCESS_COLOR_ON
                failure_on = TextwrapEx.ERROR_COLOR_ON
                warning_on = TextwrapEx.WARNING_COLOR_ON
                color_off = TextwrapEx.COLOR_OFF
            else:
                success_on = ""
                failure_on = ""
                warning_on = ""
                color_off = ""

            # ----------------------------------------------------------------------
            def DecorateRow(
                index: int,
                values: List[str],
            ) -> List[str]:
                task_data_item = task_data_items[index]

                if task_data_item.result < 0:
                    color_on = failure_on
                elif task_data_item.result > 0:
                    color_on = warning_on
                else:
                    color_on = success_on

                values[1] = "{}{}{}".format(color_on, values[1], color_off)

                if not dm.capabilities.is_headless:
                    values[3] = TextwrapEx.CreateAnsiHyperLinkEx(
                        "file:///{}".format(task_data_item.context.build_dir.as_posix()),
                        values[3],
                    )

                    values[4] = TextwrapEx.CreateAnsiHyperLinkEx(
                        "file:///{}".format(task_data_item.log_filename.as_posix()),
                        values[4],
                    )

                return values

            # ----------------------------------------------------------------------

            indented_stream = StreamDecorator(stream, "    ")

            indented_stream.write("\n\n")

            indented_stream.write(
                TextwrapEx.CreateTable(
                    [
                        "Configuration",
                        "Result",
                        "Execution Time",
                        "Output Directory",
                        "Log Filename",
                        "Short Desc",
                    ],
                    rows,
                    [
                        TextwrapEx.Justify.Left,
                        TextwrapEx.Justify.Center,
                        TextwrapEx.Justify.Left,
                        TextwrapEx.Justify.Left if dm.capabilities.is_headless else TextwrapEx.Justify.Right,
                        TextwrapEx.Justify.Left if dm.capabilities.is_headless else TextwrapEx.Justify.Right,
                        TextwrapEx.Justify.Left,
                    ],
                    DecorateRow,
                ),
            )

            indented_stream.write("\n")


# ----------------------------------------------------------------------
def _PrintHeader(
    name: str,
    output_stream: TextIO,
) -> None:
    output_stream.write(
        textwrap.dedent(
            """\


            ----------------------------------------------------------------------
            |  {}
            ----------------------------------------------------------------------

            """,
        ).format(name),
    )


# ----------------------------------------------------------------------
def _BuildImpl(
    build_dir: Path,
    output_stream: TextIO,
) -> int:
    command_line = 'cmake --build "{}"'.format(build_dir)

    output_stream.write("Command line: {}\n\n".format(command_line))

    result = SubprocessEx.Run(command_line)

    output_stream.write(result.output)
    return result.returncode


# ----------------------------------------------------------------------
def _TestImpl(
    build_dir: Path,
    output_stream: TextIO,
) -> int:
    command_line = 'ctest --parallel'

    output_stream.write("Command line: {}\n\n".format(command_line))

    result = SubprocessEx.Run(
        command_line,
        cwd=build_dir,
    )

    output_stream.write(result.output)
    return result.returncode


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
if __name__ == "__main__":
    app()
